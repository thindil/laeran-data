<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: DGD/MP and Threads
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="../LibWriting/index.html">Writing a Library</a></li>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="index.html">DGD LPC Reference</a></li>
<ul>
<li>DGD/MP and Threads</li>
<li><a href="Arrays.html">Mappings</a></li>
<li><a href="AtomicFuncs.html">Atomic Functions</a></li>
<li><a href="Calling_Conventions.html">DGD Calling Conventions</a></li>
<li><a href="CallOut.html">call_out</a></li>
<li><a href="CallTouch.html">call_touch()</a></li>
<li><a href="CallTrace.html">call_trace()</a></li>
<li><a href="CharManip.html">Character Manipulation</a></li>
<li><a href="Code_Examples.html">LPC Code Samples</a></li>
<li><a href="CreateFuncs.html">Create Funcs</a></li>
<li><a href="Diffs_in_LPC.html">DGD LPC Diffs</a></li>
<li><a href="Driver_Details.html">DGD Driver Details</a></li>
<li><a href="General_Docs.html">non-DGD Docs</a></li>
<li><a href="LinkedLists.html">Linked Lists</a></li>
<li><a href="LPC_FAQ.html">LPC FAQ</a></li>
<li><a href="Mappings.html">Mappings</a></li>
<li><a href="MPThreads.html">DGD/MP and Threads</a></li>
<li><a href="Object_Types.html">DGD Object Subtypes</a></li>
<li><a href="Parse_String.html">Using parse_string</a></li>
<li><a href="SPrintF.html">sprintf in DGD</a></li>
<li><a href="SScanF.html">sscanf in DGD</a></li>
<li><a href="ThreadLocal.html">Thread-Local Storage</a></li>
<li><a href="Unsupported.html">Unsupported Features</a></li>
</ul>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">DGD LPC Reference</a> > DGD/MP and Threads</p>



<h2>DGD/MP and Multiple Threads</h2>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Thu Apr  7 02:02:01 2005
Subject: [DGD] 1.2.102

&gt;  - Forbid having undefined private functions.
&gt;  - Add a list of undefined functions to status(obj).

To clarify: you can have a prototype for a private function, but if so
it must be declared for the same program.  So just

    private void foo();

is wrong, but

    private void foo();

    private void foo()
    {
	/* do the foo thing */
    }

is no problem.

The list of undefined functions is added so that a mudlib can forbid
active use of such objects, and can generate reasonable errormessages.
&gt;From a Java point of view, an object with only prototypes would be an
interface.

The "list" is actually a mapping.  When object obj has no undefined
functions, status(obj)[O_UNDEFINED] is nil.  Otherwise, it is a
mapping of the following format:

    ([ program_name : ({ func1, func2, ... )}, ... ])

Regards,
Dworkin



From: dgd@dworkin.nl (Par Winzell)
Date: Thu Apr  7 21:24:01 2005
Subject: [DGD] 1.2.102

Felix A. Croes wrote:

&gt; The list of undefined functions is added so that a mudlib can forbid
&gt; active use of such objects, and can generate reasonable errormessages.
&gt; From a Java point of view, an object with only prototypes would be an
&gt; interface.
&gt; 
&gt; The "list" is actually a mapping.  When object obj has no undefined
&gt; functions, status(obj)[O_UNDEFINED] is nil.  Otherwise, it is a
&gt; mapping of the following format:
&gt; 
&gt;     ([ program_name : ({ func1, func2, ... )}, ... ])

The mudlib support to provide 'proper' support for abstract functions is
not entirely trivial, and as I just finished (with Dworkin helping me
work through the issues) an implementation for the SkotOS 2.0 codebase,
I thought I'd briefly summarize my findings. This is probably only one
of many possible implementations, especially since I assume the use of
the kernel library.

 - You will want to mask compile_object() in the System level auto
object, if you are not already doing so. You need two separate systems
to check for two separate kinds of unimplemented functions:
    + For concrete objects, use status(obj)[O_DEFINED] and simply report
any unimplemented functions that are either declared in the compiled
program or inherited normally. A concrete object by definition should
not have any undefined functions.
    + The status() function does not report prototypes that were
privately inherited. It is quite common to privately inherit a program
that declares prototypes it expects its inheritor to implement. To catch
cases where the inheritor fails to implement them:
      * Allocate space for a new TLS slot.
      * In your objectd, add code to forbid_inherit(), compile() and
compile_lib() that keeps track of the undefined functions of each
privately inherited program.
      * In your masked compile_object(), initialize the TLS slot with
whatever data you need for the previous step. Remember that compilation
of one program may trigger compilation of many other programs when
creators are run.
      * At the end of compile_object(), go through the datastructure
(which is likely quite large) you collected in the objectd. For each
compiled program:
        $ Figure the master list of privately inherited undefined functions.
        $ From this master list, REMOVE any undefined functions that
were NON-privately inherited. If I inherit a prototype both privately
and non-privately, the private inheritance is irrelevant.
        $ From the rest of the master list, REMOVE any function that is
actually defined by the compiled program. To do this, you will need to
employ function_object(), but:
          = function_object() from the 'outside' fails to detect static
methods and so you need to create some kind of function_exists() relay
in the auto object that performs function_object() on itself
          = function_object() cannot be run on pure programs, because
the kernel library forbids us from getting an object pointer to such a
program; thus we create a temporary object that does very little but
inherit the program we actually want to test, and then call
function_exists() on this program.


Phew. OK, that sounded complicated. I guess it was. But it works! LPC
has matured even further!

Zell
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
