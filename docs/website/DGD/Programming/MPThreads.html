<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: DGD/MP and Threads
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="../LibWriting/index.html">Writing a Library</a></li>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="index.html">DGD LPC Reference</a></li>
<ul>
<li><a href="AbstractFuncs.html">DGD/MP and Threads</a></li>
<li><a href="Arrays.html">Mappings</a></li>
<li><a href="AtomicFuncs.html">Atomic Functions</a></li>
<li><a href="Calling_Conventions.html">DGD Calling Conventions</a></li>
<li><a href="CallOut.html">call_out</a></li>
<li><a href="CallTouch.html">call_touch()</a></li>
<li><a href="CallTrace.html">call_trace()</a></li>
<li><a href="CharManip.html">Character Manipulation</a></li>
<li><a href="Code_Examples.html">LPC Code Samples</a></li>
<li><a href="CreateFuncs.html">Create Funcs</a></li>
<li><a href="Diffs_in_LPC.html">DGD LPC Diffs</a></li>
<li><a href="Driver_Details.html">DGD Driver Details</a></li>
<li><a href="General_Docs.html">non-DGD Docs</a></li>
<li><a href="LinkedLists.html">Linked Lists</a></li>
<li><a href="LPC_FAQ.html">LPC FAQ</a></li>
<li><a href="Mappings.html">Mappings</a></li>
<li>DGD/MP and Threads</li>
<li><a href="Object_Types.html">DGD Object Subtypes</a></li>
<li><a href="Parse_String.html">Using parse_string</a></li>
<li><a href="SPrintF.html">sprintf in DGD</a></li>
<li><a href="SScanF.html">sscanf in DGD</a></li>
<li><a href="ThreadLocal.html">Thread-Local Storage</a></li>
<li><a href="Unsupported.html">Unsupported Features</a></li>
</ul>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">DGD LPC Reference</a> > DGD/MP and Threads</p>



<h2>DGD/MP and Multiple Threads</h2>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Mon Apr  4 21:57:01 2005
Subject: [DGD] DGD MP and a TLS idea

Steve Wooster wrote:

&gt;      The current version of the kernel isn't MP optimized, right? At least 
&gt; for version 1.2.86 (I think that's the version I have) it looks like 
&gt; call_outs are registered in a central daemon... Since I'm fiddling around 
&gt; with creating a mudlib from scratch (I'm only doing it for fun, not because 
&gt; I expect to actually get far on it), I was wondering if there's a good way 
&gt; to handle things like being able to pause call_outs that isn't effectively 
&gt; single-threaded.

I'm not sure what you mean by this.  But the MP version will simulate
a single-threaded succession of LPC execution rounds, so it's not going
to be any different for the mudlib programmer in that respect.


&gt;      Also, for thread local storage, it occurred to me that the argument 
&gt; passed could be a mapping instead of an array... then you could have things 
&gt; like: (I forgot the exact code, so this probably won't work... but it 
&gt; should give you the general idea)
&gt; Inside the auto object:
&gt;
&gt; static void set_tls( mixed setting, mixed value )
&gt; {
&gt;      if (trace()[1][FIRST_ARG][this_object()] == nil)
&gt;          trace()[1][FIRST_ARG][this_object()] = ([]);
&gt;      trace()[1][FIRST_ARG] [this_object()][setting] = value;
&gt; }
&gt;
&gt; static mixed query_tls( mixed setting )
&gt; {
&gt;      return( trace()[1][FIRST_ARG] [this_object()][setting] );
&gt; }

The point of having TLS is that it's shared between all objects.  If each
object has its own TLS variables, they might as well be in the object. :)

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Steve Wooster)
Date: Mon Apr  4 22:09:02 2005
Subject: [DGD] DGD MP and a TLS idea

     It occurred to me that what I meant by my description of call_outs 
being "effectively single-threaded" might not have been clear... From what 
I can tell, only one call_out can occur at a time. You can't have two 
different call_outs running on two different processors, since they'll 
always conflict with each other when checking if they've been suspended. 
(or is this not true, since they don't necessarily write to variables?)

-Steve Wooster
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Mon Apr  4 23:09:01 2005
Subject: [DGD] DGD MP and a TLS idea

Steve Wooster wrote:

&gt;      It occurred to me that what I meant by my description of call_outs 
&gt; being "effectively single-threaded" might not have been clear... From what 
&gt; I can tell, only one call_out can occur at a time. You can't have two 
&gt; different call_outs running on two different processors, since they'll 
&gt; always conflict with each other when checking if they've been suspended. 
&gt; (or is this not true, since they don't necessarily write to variables?)

It's all right to have two threads simultaneously access the same object,
as long as neither modifies it.  But suspension of all callouts in a mud
should be a sufficiently rare event that there isn't much point in
optimizing for it.


&gt;[...]
&gt; I figured it might be useful for cases where you want data stored 
&gt; per-object, but don't want two threads with the same object to conflict. 
&gt; ...maybe I don't know enough about what will or won't cause two threads to 
&gt; conflict with each other.

I am deliberately going to keep this vague since implementation details
which might well change should not influence mudlib design to that extend.
But you should assume that it's fine for a thread to modify the object it
starts in.  Beyond that, the fewer objects modified the better.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Mon Apr  4 23:22:01 2005
Subject: [DGD] 3 golden rules for MP

1) Try to modify as few objects as possible in a single execution round,
   other than the object you start in.
2) Try to avoid modifying the object you add a callout for.  If possible,
   delay modification until when the callout actually executes.
3) Avoid starting all execution rounds from the same small set of objects.

About terminology: I decided to call the time slice during which an LPC
event program is running an "execution round".  It's not really a thread,
and talking about them as "threads" confuses the issue when you also have
to deal with actual threads.

Regards,
Dworkin
</pre>
<hr>
<pre>
From dgd@dworkin.nl  Tue Apr  5 01:14:01 2005
From: dgd@dworkin.nl (Par Winzell)
Date: Tue Apr  5 00:14:01 2005
Subject: [DGD] 3 golden rules for MP

&gt; 1) Try to modify as few objects as possible in a single execution round,
&gt;    other than the object you start in.
&gt; 2) Try to avoid modifying the object you add a callout for.  If possible,
&gt;    delay modification until when the callout actually executes.
&gt; 3) Avoid starting all execution rounds from the same small set of objects.

To my mind, 1) and 3) are fairly intuitive, and I think I know
reasonably well how to go about structuring a mudlib to avoid lots of
clashes. But 2) seems problematic to me, especially if 3) prohibits us
from offloading hearbeat-style issues on central objects.

At least in terms of virtual worlds, almost everything of interest needs
timed events, almost certainly involving objects with continuously
fluctuating state -- players, NPCs, items, rooms, ...

Some of these timed events can be deferred, perhaps using call_touch()
somehow. For a traditional example, if we know the health of a monster
increases linearly with time, query_health() can just figure out how
much healing has taken place since the last time health was queried.
Generally, we might have a way to update any deferrable state changes
whenever they're requested.

But that's only some kinds of state. In games, we generally rely on
state changes to push out to players... in a text game, descriptive
statements are transmitted; in a 3D world, little packets are sent out
telling the clients to update their view of the world. In effect, this
is sensory state and for practical purposes we have to treat it as if it
is continuously queried, and no deferred updates are really possible.

What's an architecture that does the right thing with threads here? If
we have a text game where a player tosses an egg into the air, we need a
3-second timed event for when the egg lands. It's pretty likely that
after three seconds, the state has changed in the room, the player doing
the tossing, and many of the lookers-on. Even if nobody touches their
keyboards, three seconds later, we need an asynchronous message telling
us about the egg smacking into the floor.

Should every 'important' object have a little time-keeper object whose
only purpose in life is to maintain callouts? If its only duty is to
start message-sending threads in other players, does that count as
damagable state?

And just how careful does one have to be about all this?

Zell
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Tue Apr  5 01:21:01 2005
Subject: [DGD] 3 golden rules for MP

Par Winzell wrote:

&gt; &gt; 1) Try to modify as few objects as possible in a single execution round,
&gt; &gt;    other than the object you start in.
&gt; &gt; 2) Try to avoid modifying the object you add a callout for.  If possible,
&gt; &gt;    delay modification until when the callout actually executes.
&gt; &gt; 3) Avoid starting all execution rounds from the same small set of objects.
&gt;
&gt; To my mind, 1) and 3) are fairly intuitive, and I think I know
&gt; reasonably well how to go about structuring a mudlib to avoid lots of
&gt; clashes. But 2) seems problematic to me, especially if 3) prohibits us
&gt; from offloading hearbeat-style issues on central objects.

The second rule follows from the first.  If you have an occasion where
a lot of objects are modified together -- for example, a message broadcast
to all players -- you can lessen the impact by breaking it up with callouts.
The broadcaster does not directly force each player to process a message,
but instead starts a zero-delay callout in each player object to do so.

This introduces a whole new reason for having zero-delay callouts, and
I expect that the amount of them will probably exceed the "normal"
callouts by at least one order of magnitude.  The second rule must be
seen in that context.  It applies to all of such "followup" callouts,
and therefore to the vast majority of callouts.  Of course, there are
still a number of "ordinary" callouts for which it makes no sense.

None of the rules are absolute, and all of them can be broken when
there is sufficient reason for doing so.  Rule 2 is very important
when you mask call_out() in the auto object, it would be a disaster
if there is some variable modified along with &lt;every&gt; added callout.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Tue Apr  5 01:26:01 2005
Subject: [DGD] 3 golden rules for MP

Steve Wooster wrote:

&gt;[...]
&gt; For 3, what about a heartbeat-ish daemon for objects in combat to ensure 
&gt; that objects which take more CPU don't end up with less rounds of combat, 
&gt; or healing more slowly/etc? Would that just be a necessary evil to ensure 
&gt; that certain types of actions occur at the same speed? More importantly, is 
&gt; there a better way to do that than to have it notify each object using a 
&gt; different time-slice (using call_out with a delay of 0), then do a call_out 
&gt; for the next round?

That's fine, as long as it doesn't break rule 1 (i.e. it shouldn't, in
a single execution round, modify the internal state of all players/monsters
in combat in the mud).  It only violates rule 3 when there are a lot of
competing callouts trying to simultaneously run in that heartbeat daemon.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Fri Apr 15 02:50:01 2005
Subject: [DGD] DGD/MP 1.0

I've just put together a version of DGD/MP which I'll call 1.0.  It has
working MP support :-)  Though I still have a lot of debugging to do and
disabled subsystems to complete.  The mostly-bugfree version will be 1.1,
and 1.2 will run on platforms other than a Mac.  1.2 will be the first
version I am going to release, which should be in a few months.  After
that, I intend that both DGD and DGD/MP advance to version 1.3
simultaneously.

I've been planning to create a MP capable version of DGD for a long
time; since 1997, in fact.  Many other features came first (parse_string,
private inheritance, nil, atomic functions, light-weight objects,
arbitrary size numbers with crypto, call_touch, IPv6 support...)  At this
point, DGD finally has everything I wanted it to have 10 years ago.

Implementing multi-processor support has taken me a lot more time and
effort than I thought it would.  I've found that doing MP properly is
hard.  Very, very hard.  It's so easy to overlook something and make it
merely multi-threaded, with all threads depending on some bottleneck,
and without properly utilizing all processors.

It's going to take still more time to tune things properly for an actual
mudlib designed for MP.  Most of that will happen after version 1.3.

Anyway, the first milestone has been reached.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Tue Apr 19 14:07:01 2005
Subject: [DGD] DGD/MP 1.0

"Christopher Allen" wrote:

&gt; I was trying to find a description of the approach that you've taken with
&gt; DGD/MP to give someone else. My less then CompSci interpretation of what
&gt; makes it unique is that programatically you program largely as if you are
&gt; single-threaded, but that DGD/MP will handle the issues of multiprocessor
&gt; message passing bottlenecks and throttling through both intelligent design
&gt; and through rollback of functions marked atomic. Obviously some care has to
&gt; be taken with "single-thread" style code, but that largely it is much easier
&gt; to program.
&gt;
&gt; However, my non-CompSci description of the merits of your approach is not
&gt; suitable to passing on to others. Can you write up something brief about
&gt; your unique approach and why it is superior to some of the other methods of
&gt; programming for MP?

The compsci version:

    Maurice Herlihy: "A methodology for implementing highly concurrent
    data objects," ACM Transactions on Programming Languages and Systems,
    15(5):745-770, 1993.

The intermediate version:

    The server concurrently runs threads of finite duration on a copy
    of the data.  Once a thread completes, the changes it made in the
    copy will be committed to the original data if no other thread has
    modified that part of the original data in the meanwhile; otherwise
    the thread will be rescheduled.

Atomic functions are not involved in this, though they are conceptually
similar.

I actually started using the term "execution round" instead of "thread"
because it makes more sense, but that may be considered incomprehensible
jargon, you be the judge.  It may require explaining the LPC execution
model. :)

The non-compsci version:

    A single-threaded server is simulated using a MP server, and there
    is nothing to worry about.


In all cases, the advantage of this approach is that the great complexity
of MP design is hidden from the LPC programmer.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Par Winzell)
Date: Tue May 10 16:59:01 2005
Subject: [DGD] Command Finders

Noah Gibbs wrote:
&gt;   The way you'll want to do this_player() is to have a variable somewhere that
&gt; gets set appropriately and queried with a function (maybe called "this_player")
&gt; in your AUTO object.

I'd say allocate a TLS (Thread Local Storage) slot, and stuff it with a
LWO of your own making at the beginning of every thread. This LWO could
keep track of things like the current this_player() per thread, rather
than globally.

Zell
</pre>
<hr>
<pre>
From: dgd@dworkin.nl (Kris Van Hees)
Date: Thu Jun 23 00:51:01 2005
Subject: [DGD] Why export data structures?

Older versions of DGD actually handled arrays and mappings as references to a
single instance of the structure, until the object got swapped out (which did
cause the object to getits own copy of the structure data).  Because swapping
of objects was unpredictable, that behaviour got changed to be more specific.
I remember long conversations with Dworkin about that logic, because I was in
fact implementing just that as part of my Master's Thesis.  The logic in  DGD
reflects the same concept, with Dworkin's own implementation (and as far as I
can see that implementation has of course also evolved over time  with  other
features being added to DGD).

	Cheers,
	Kris


On Wed, Jun 22, 2005 at 03:44:37PM -0700, Noah Gibbs wrote:
&gt;   There are probably many fine reasons.  One reason is that the way DGD handles
&gt; memory strongly suggests it.  DGD handles its memory in very explicit chunks -
&gt; specifically, each DGD 'object' is managed as a single chunk.  Objects can
&gt; point at each other, but pointing at sub-objects (like mappings, LWOs or
&gt; arrays) inside other DGD objects would require the memory management to be
&gt; messier.
&gt; 
&gt;   Currently DGD can have a single identifier for each DGD object, so you can
&gt; potentially have four billion of them.  Being able to point to sub-objects
&gt; would give you less 'name space' in that sense.  I guess you could point to
&gt; sub-objects as offsets from the start of their actual object - but then, that's
&gt; pretty much the equivalent of how you handle them now in LPC.
&gt; 
&gt;   Also, currently it's easy to tell when you might be pulling a bunch of new
&gt; stuff into memory.  If you could reference other people's sub-objects without
&gt; using DGD object pointers, you'd have a bunch of other cases where you could be
&gt; pulling their stuff into memory.
&gt; 
&gt;   None of this actually demands that you not be able to touch other people's
&gt; sub-objects, they're just reasons why it's basically a good idea not to.  I
&gt; don't know of any reason why DGD couldn't be altered to do this, though I
&gt; expect it'd be a lot of work.
&gt; 
&gt; --- Petter Nystr√∂m wrote:
&gt; 
&gt; &gt; Hello!
&gt; &gt; 
&gt; &gt; This is really just a question out of curiousity. I was thinking of coding 
&gt; &gt; something that relied on several objects having access to the same data 
&gt; &gt; structure - in this case a mapping. But then I learned that such data 
&gt; &gt; structures are made into individual copies in all objects referencing it 
&gt; &gt; at the end of the execution thread. So as I understand it, the objects 
&gt; &gt; would no longer be referencing the same data in later threads.
&gt; &gt; 
&gt; &gt; Now, I have no reason to be upset why it works like this. I am merely 
&gt; &gt; being curious as to the reasons. Why does DGD do this? If someone's got 
&gt; &gt; the time to satiate my curiousity, I'd be happy!
&gt; &gt; 
&gt; &gt; Regards,
&gt; &gt; 
&gt; &gt; Jimorie
</pre>
<hr>
<pre>
From dgd@dworkin.nl  Thu Jun 23 01:54:01 2005
From: dgd@dworkin.nl (Felix A. Croes)
Date: Thu Jun 23 00:54:01 2005
Subject: [DGD] Why export data structures?

[oops -- original response not sent to the list]

&gt; This is really just a question out of curiousity. I was thinking of coding
&gt; something that relied on several objects having access to the same data
&gt; structure - in this case a mapping. But then I learned that such data
&gt; structures are made into individual copies in all objects referencing it
&gt; at the end of the execution thread. So as I understand it, the objects
&gt; would no longer be referencing the same data in later threads.
&gt;
&gt; Now, I have no reason to be upset why it works like this. I am merely
&gt; being curious as to the reasons. Why does DGD do this? If someone's got
&gt; the time to satiate my curiousity, I'd be happy!

That way, all data remains local to a (persistent) object.  The only
crossreferences between objects are those that pass through an object
reference, which is handled in a special way.  As a result, memory
management and swapfile allocation become much simpler and scale
better.

This is even more important for DGD/MP.

Regards,
Dworkin
</pre>
<hr>
<pre>
From dgd@dworkin.nl  Thu Jun 23 02:30:01 2005
From: dgd@dworkin.nl (Felix A. Croes)
Date: Thu Jun 23 01:30:01 2005
Subject: [DGD] Why export data structures?

Dread Quixadhal wrote:

&gt; My guess would be that it has to do with two features of the driver in 
&gt; particular.  First, it would make life much simpler for multi-processor 
&gt; support if every thread could have distinct data segments that didn't 
&gt; rely on conflicting access with other threads.  When those threads are 
&gt; running concurrently, there are all sorts of locking techniques you need 
&gt; to use if they can touch the same bits of data.

When data is not local to objects, you'd need a separate lock for every
datastructure that can be referenced...  you might call that "death by
a thousand locks." :)


&gt; Secondly, it seems like having separate copies of each thread's data 
&gt; structures would make atomic function roll-back considerably simpler.  
&gt; If thread N calls a function that fails and gets rolled back, it doesn't 
&gt; have to then also mark threads O..Z as "dirty" since they all still have 
&gt; their own data which might (or might not) work for them.

This isn't true because atomic rollback happens within an execution
round, where data &lt;can&gt; be shared between objects.  Atomic rollback
therefore is implemented for datastructures, not for object dataspaces,
but the overhead is still quite reasonable, precisely because the
situation can only persist for the duration of the execution round.


&gt; To satisfy my own curiosity, is it actually always copied, or is it 
&gt; copy-on-write?  IE:  If two threads both start with the same (statically 
&gt; declared and filled?) array, and both read from it but don't modify it, 
&gt; do we have two copies in memory, or just one with two pointers?

There would be three instances: one original which is only modified when
a change is committed, and two copies, one in each thread's own memory
space.  Memory is cheap these days, and avoiding locking is more important
than saving space.

DGD/MP uses much, much more memory than DGD.

Regards,
Dworkin
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
