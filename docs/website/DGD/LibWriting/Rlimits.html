<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: Rlimits
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="index.html">Writing a Library</a></li>
<ul>
<li><a href="ChangingLPC.html">Changing LPC</a></li>
<li><a href="Cleanup.html">Object Cleanup</a></li>
<li><a href="CmdsOrNot.html">&frasl;cmd vs wiztool</a></li>
<li><a href="CondInherit.html">Conditional Inheritance</a></li>
<li><a href="Database.html">Object Database</a></li>
<li><a href="DistStateDump.html">Distribute a State Dump?</a></li>
<li><a href="DriverObj.html">Designing Driver Objs</a></li>
<li><a href="FTPD.html">FTPD</a></li>
<li><a href="GurbaLib.html">GurbaLib</a></li>
<li><a href="HeartBeat.html">State Dumps</a></li>
<li><a href="Heaven7.html">Heaven7</a></li>
<li><a href="HTTPD.html">HTTPD</a></li>
<li><a href="IMUD3.html">InterMUD3</a></li>
<li><a href="InterruptCall.html">Interrupt Call</a></li>
<li><a href="LargeAuto.html">Designing AUTO Objs</a></li>
<li><a href="LittleIssues.html">Misc Issues</a></li>
<li><a href="NFS.html">NFS</a></li>
<li><a href="ObjBinding.html">Object Binding</a></li>
<li><a href="ObjectManagement.html">Object Management</a></li>
<li><a href="OtherServices.html">Other Net Services</a></li>
<li><a href="Persistence.html">Persistent MUDLibs</a></li>
<li><a href="PlayerBody.html">Player vs Body</a></li>
<li><a href="Precompiling.html">Precompiling</a></li>
<li><a href="Reimplementation.html">Reimplementing From Scratch</a></li>
<li><a href="Releasing.html">Releasing Code</a></li>
<li>Rlimits</li>
<li><a href="ScriptDelays.html">Script Delays</a></li>
<li><a href="Security.html">Misc Security</a></li>
<li><a href="Sendmail.html">Outgoing Email</a></li>
<li><a href="SoYouWanna.html">So You Want To...</a></li>
<li><a href="StartingNew.html">Start from Scratch?</a></li>
<li><a href="SupDocs.html">Supplementary Documentation</a></li>
<li><a href="Telnet.html">Telnet Protocol</a></li>
<li><a href="UseKernel.html">Using the Kernel</a></li>
<li><a href="UseMelville.html">Using Melville</a></li>
<li><a href="UsePhantasmal.html">Using Phantasmal</a></li>
<li><a href="WebDAV.html">WebDAV</a></li>
<li><a href="WhatLicense.html">Which License</a></li>
</ul>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="../Programming/index.html">DGD LPC Reference</a></li>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">Writing a Library</a> > Rlimits</p>



<h2>Using rlimits() in your Library</h2>

<p>The rlimits() DGD construct can be used to keep your MUD running
despite infinite loops and infinite recursions in code. In
combination with status(), it can be used for profiling your code
and keeping track of how much processor time each wizard, or each
function, is taking up. If you're not using the Kernel Library, you
need to understand rlimits() intimately to avoid infinite
recursions and loops. If you <i>are</i> using the Kernel Library,
it can still be useful here and there.</p>

<p>It turns out that rlimits() isn't actually a function, which is
why it can have the odd syntax it does. Specifically, it gets used
this way:</p>
<pre>
rlimits(-1;-1) {
  &frasl;* Some code goes here *&frasl;
}
  
</pre>

<p>Rlimits has two parameters, both set to -1 above. The first is
the limit on the stack depth, the second is the limit on the tick
count. If the code inside the curly braces exceeds either limit, an
error occurs. When either limit is -1, that means unlimited &mdash;
no limit to stack depth, or no limit to tick count.</p>

<p>The stack depth is a measure of how many functions are active at
once. Functions call each other, and those call other functions, to
greater and greater depth, and more data is allocated. As that
happens, the stack depth gets closer and closer to the limit. This
prevents an infinite (or just very deep) recursion inside the
rlimits() statement.</p>

<p>Ticks are a processor-independent measurement of how much time
the code is likely to take. Felix calls them "a weighted measure of
the number of instructions and the size of the datastructures
manipulated by these instructions". Since DGD focuses strongly on
compatibility, it's important that the measurement be
cross-platform. Each operation in DGD takes a number of ticks,
depending on what the operation is, and what data it is operating
on. Some operations, like 32-bit integer addition, will always take
the same number of ticks. Some operations, like parse_string(),
will take a widely-varying number of ticks, depending on what the
inputs to that operation are.</p>

<p>The status() call returns an array of interesting information.
One offset within this array is to the current tick count, which
increases over time as operations occur. This can be used to
determine how close to the tick limit your code is, and to profile
code or 'bill' different operations for the number of ticks they
use up.</p>

<p>The use of rlimits() is to prevent infinite recursions or
infinite loops in suspect code &mdash; code that you're not
entirely sure will return in a reasonable amount of time, or at
all. Any operation based on player data, for instance, is likely to
be in this category since somebody might want to bring your MUD to
a halt with a complicated operation. Your library may want to limit
its <i>own</i> actions as well, so that faulty code on your part is
less likely to crash the entire game.</p>

<p>To be <i>really</i> certain, just set up an rlimits() call from
every place that DGD calls into your code. That means the driver
object and the user object, several calls in each.</p>

<p>Good places to set rlimits() include:</p>

<ul>
  <li>call_out calls (when they start executing, not when they're
  scheduled)</li>

  <li>compile_error(), runtime_error() in DRIVER object</li>

  <li>&lt;create&gt;() functions</li>

  <li>receive_message() in USER object</li>

  <li>open(), close() in USER object</li>
</ul>

<p>You should also be careful to specifically limit any
user-supplied code or builder-supplied code. If you have room
scripts or other (relatively) inessential code, don't be shy about
putting an rlimits() around it with a more restrictive set of
limits. That keeps such code from burning through too many of your
ticks.</p>

<p>Rlimits often goes well with a catch() statement so that if the
code runs too long or recurses too deep, you can log a more
meaningful error about exactly what code caused the problem.</p>

<p>You'll want to make sure that an rlimits() <i>inside</i> the one
you put in place can't override you. Somebody can put an
rlimits(-1;-1) somewhere inside the code you limited, and then the
error won't be caused if they go into an infinite loop. Luckily,
DGD will query your DRIVER object every time somebody attempts an
rlimits() statement, so you'll need to make sure your rlimits()
statement works (to limit them) and their doesn't work when they
try to override you. See the Kernel Library for good examples of
how to use rlimits(), including not letting the code you call
override your limits. The MudOSalike package, by Frank Schmidt, is
also a good example of rlimits().</p>

<p>Here is a bit of a tutorial, this one by Erwin Harte:</p>
<pre>
To make sure a function started by a call_out() is wrapped inside such
an rlimits construct, you would have to redefine call_out() in your
auto-object, like this:

    static int
    call_out(string func, int delay, mixed args...)
    {
        return ::call_out("_F_call_out", delay, func, args);
    }

    nomask void
    _F_call_out(string func, mixed *args)
    {
        if (previous_program()) {
	    rlimits (MAX_STACK; MAX_TICKS) {
		call_other(this_object(), func, args...);
	    }
        }
    }

The 'if (previous_program()) {' condition is to make sure the function
cannot be abused by calling it directly, this way it will only call
the given function with the parameters if it's the start of a thread.

If you're thinking of making _F_call_out() a static function, think
again, because that would make it an 'efun' since it's in the auto-
object, and then you cannot call it from a call_out(). :-)
</pre>
<hr>
<pre>
From: DGD Mailing List (Felix A. Croes)
Date: Sat Apr  5 14:20:01 2003
Subject: [DGD] Interaction of catch{} and rlimits{}

Noah Lee Gibbs wrote:

&gt;   Say you're within an rlimits{} construct, perhaps as a result of being 
&gt; called by the Kernel Library's call_limited() function.  You have limited 
&gt; ticks available.
&gt;   Say you're within a catch{} statement within that rlimits{}, and the 
&gt; catch{} has one of those "do on error" sections.  Now say in the body of 
&gt; the catch{}, you run out of ticks.
&gt;   You'd like to do the "do on error" stuff but you're out of ticks.  
&gt; Should we always use an extra rlimits{..;-1} around any catch{} statement 
&gt; where we *really* want the "on error" block to execute?

When error recovery is essential, there are two things you can do.

1. You can make sure that something happens using rlimits:

    rlimits (0; -1) {
	catch {
	    call_limited("foo");
	} : {
	    /*
	     * this MUST complete to fully recover from an error
	     */
	    bar();
	}
    }

   There are several problems with this approach.  First, when using
   the kernel library, only System objects can use rlimits (...; -1).
   Second, an infinite loop in bar() will hang your mud forever.
   Third, even though foo() is called with limits appropriate for the
   current object, those limits are reset for the call, thanks to the
   enclosing rlimits (..; -1).  Fourth, the ticks spent in bar() will
   not be accounted for using the kernel library's resource management
   system.

2. You can make sure that nothing happened, using atomic functions:

    atomic void foo()
    {
	/*
	 * an error inside this function will undo all the actions
	 * performed inside this function
	 */
    }

   Atomic functions can be used by anyone.  They have two drawbacks:
   first, you cannot do file-changing actions inside them.  Second,
   they take twice the amount of ticks that would ordinarily be
   spent in that function.  Therefore, it makes sense to keep the
   actions performed in these functions to a minimum.

   However, since the actual time spent inside atomic functions is
   usually far less than twice that of an equivalent non-atomic
   function, an alternative would be to take that overhead for granted,
   double all tick quotas, and use atomic functions all through your
   mudlib.  The latter approach was taken by Skotos.  Practically
   everything in a Skotos mud is performed atomically.

Pick whichever solution suits you best.  

Regards,
Dworkin
</pre>
<hr>
<pre>
From: DGD Mailing List (Felix A. Croes)
Date: Mon Mar 29 05:13:01 2004
Subject: [DGD] rlimits

Steve Wooster wrote:

&gt;      I'm a little confused about exactly how rlimits works... I understand 
&gt; that you put it around code to limit how many tick/etc that code can take 
&gt; up, but I'm confused as to how rlimits within rlimits works...
&gt;
&gt; For example: (I've forgotten whether ticks or recursion depth comes first, 
&gt; so I'll say "ticks" or "depth" after the numbers)
&gt;
&gt; void func()
&gt; {
&gt;      rlimits (10 depth, 100 ticks)
&gt;      {
&gt;          code that uses 50 ticks;
&gt;          rlimits (10 depth, -1 ticks)
&gt;          {
&gt;              code that uses 25 ticks;
&gt;          }
&gt;          // Are there 50 ticks remaining or only 25?
&gt;      }
&gt; }

50 ticks remaining.


&gt; Now that I've typed this out, I think I know what I want to ask... When you 
&gt; use an rlimits construct inside another one, does code inside the inner 
&gt; rlimits it count towards the ticks for the outer rlimits? It seems like the 
&gt; most logical answer would be "no", but I'd feel better if somebody 
&gt; confirmed this.

The inner ticks don't count for the outer rlimits.  However, the mudlib
has some say in this, since each use of rlimits() is checked at compile
time and possibly also at runtime.  The kernel library doesn't allow
increasing the resource limits beyond what they currently are, &lt;unless&gt;
the current object is a System object.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: DGD Mailing List (Felix A. Croes)
Date: Mon Mar 29 14:40:02 2004
Subject: [DGD] rlimits

Steve Wooster wrote:

&gt; Could that allow code to do something like this without running out of 
&gt; ticks? (assume depth comes first, ticks comes second in the argument list)

The syntax is: rlimits (depth; ticks) { ... }


&gt; void func()
&gt; {
&gt;      // Assume I have 100 ticks remaining.
&gt;      // Assume rlimits uses 5 ticks.
&gt;      rlimits (0,95)
&gt;      {
&gt;          Code that takes up 90 ticks;
&gt;      }
&gt;      rlimits (0,90)
&gt;      {
&gt;          Code that takes up 85 ticks;
&gt;      }
&gt;      // Are there still about 90 ticks left despite having
&gt;      // executed 175 ticks worth of code?
&gt; }

Yes.

Regards,
Dworkin
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
