<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: Persistent MUDLibs
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="index.html">Writing a Library</a></li>
<ul>
<li><a href="ChangingLPC.html">Changing LPC</a></li>
<li><a href="Cleanup.html">Object Cleanup</a></li>
<li><a href="CmdsOrNot.html">&frasl;cmd vs wiztool</a></li>
<li><a href="CondInherit.html">Conditional Inheritance</a></li>
<li><a href="Database.html">Object Database</a></li>
<li><a href="DistStateDump.html">Distribute a State Dump?</a></li>
<li><a href="DriverObj.html">Designing Driver Objs</a></li>
<li><a href="FTPD.html">FTPD</a></li>
<li><a href="GurbaLib.html">GurbaLib</a></li>
<li><a href="HeartBeat.html">State Dumps</a></li>
<li><a href="Heaven7.html">Heaven7</a></li>
<li><a href="HTTPD.html">HTTPD</a></li>
<li><a href="IMUD3.html">InterMUD3</a></li>
<li><a href="InterruptCall.html">Interrupt Call</a></li>
<li><a href="LargeAuto.html">Designing AUTO Objs</a></li>
<li><a href="LittleIssues.html">Misc Issues</a></li>
<li><a href="NFS.html">NFS</a></li>
<li><a href="ObjBinding.html">Object Binding</a></li>
<li><a href="ObjectManagement.html">Object Management</a></li>
<li><a href="OtherServices.html">Other Net Services</a></li>
<li>Persistent MUDLibs</li>
<li><a href="PlayerBody.html">Player vs Body</a></li>
<li><a href="Precompiling.html">Precompiling</a></li>
<li><a href="Reimplementation.html">Reimplementing From Scratch</a></li>
<li><a href="Releasing.html">Releasing Code</a></li>
<li><a href="Rlimits.html">Rlimits</a></li>
<li><a href="ScriptDelays.html">Script Delays</a></li>
<li><a href="Security.html">Misc Security</a></li>
<li><a href="Sendmail.html">Outgoing Email</a></li>
<li><a href="SoYouWanna.html">So You Want To...</a></li>
<li><a href="StartingNew.html">Start from Scratch?</a></li>
<li><a href="SupDocs.html">Supplementary Documentation</a></li>
<li><a href="Telnet.html">Telnet Protocol</a></li>
<li><a href="UseKernel.html">Using the Kernel</a></li>
<li><a href="UseMelville.html">Using Melville</a></li>
<li><a href="UsePhantasmal.html">Using Phantasmal</a></li>
<li><a href="WebDAV.html">WebDAV</a></li>
<li><a href="WhatLicense.html">Which License</a></li>
</ul>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="../Programming/index.html">DGD LPC Reference</a></li>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">Writing a Library</a> > Persistent MUDLibs</p>



<h2>Persistent MUD Libraries &mdash; Yes or No?</h2>

<p>The DGD server, written by the excellent Dworkin, has changed a
lot from its conceptual roots in LPMUD. The language is very
different, the server features are very different. Its dialect of
the LPC language is strongly based on the original LPC, and thus on
C. But one of the visions that has driven some of DGD's most
powerful and unusual features is persistence. Persistence makes a
major difference in a MUD library, and you'll need to decide early
on whether you want to take the effort to support it.</p>

<p>If you <i>do</i> decide to use persistence in a DGD MUDLib, the
<a href="../Kernel">Kernel Library</a> is worth a second look. It
includes extra support for a lot of the issues that persistence can
cause your MUD.</p>

<h3>DGD's Definition of Persistence</h3>

<p>You'll hear the phrase 'persistent MUD' batted around a lot, and
'persistent world' batted around even more often. It can mean any
of several different things. The DGD community talks about DGD
providing excellent support for a persistent MUD. What do they mean
by it?</p>

<p>The phrases often refer to the game design. However, DGD can't
dictate your game design. <a href=
"../GameDesign/GamePersistence.html">Persistent game design</a> is
a different topic.</p>

<p>Primarily, the DGD community means that the game runs as though
it would never shut down, and as though the server never went down,
even if the server <i>will</i> go down. DGD is said to be
persistent because the entire state of the game in memory can be
preserved when the server is rebooted. This allows the game to
resume in exactly the same condition that it was in when the server
shut down, including all internal variables of all objects. The
game, as a single 'virtual run' of the program, never stops and
rarely even pauses. DGD's definition of Persistence involves being
able to keep actual LPC-language objects around, potentially
forever. The object pointers never expire, you never have to save
or restore, you never need to write code to back up your objects
&mdash; because conceptually, the server never, never goes
down.</p>

<p>Par Winzell probably explained it best:</p>

<p style="color: #2020FF">It's almost impossible to convey the
experience of running a truly persistent Mud to somebody who has
never done it. So many assumptions disappear. The way objects are
created, areas designed, everything changes.</p>

<p style="color: #2020FF">In traditional LPMud, virtually
everything is an initialization script, like the create() function
in your example. Half the code in a wizard's directory is startup
code. In a persistent world, rather than write a lot of startup
code, you tend to write behaviour code, and configure objects.</p>

<p style="color: #2020FF">Most code in a traditional LPMud isn't
real code, it's just a cumbersome configuration (set_this and
set_that) technique. That pretty much goes away in a persistent
game.</p>

<p style="color: #2020FF">The cumulative effect is that if you
design your mudlib to be fully persistent from scratch, you will
find yourself making subtly different decisions on pretty much
every single design question that comes up, and you end up with
something drastically different than LPMud.</p>

<h3>DGD Support for Persistence</h3>

<p>If you're never going to shut the server down, you need the
ability to <a href="ObjectManagement.html">upgrade your LPC objects
in place</a>. Eventually you'll want to add new features, new
content, new code. That means changing the code and data of
existing LPC-language objects, and adding new code and data to
them. Since you're never going to stop your current run of the
program, you'll want to deploy all that immediately, preferably
without even logging your players out. DGD allows you to do
this.</p>

<p>One way DGD simulates a single continuous run of the program is
the <a href="../Operation/StateDumps.html">State Dump</a>. A State
Dump dumps a copy of all your LPC objects, whether in memory or
swapped out, with all connections between them, to a file. You may
then, later, start DGD from that State Dump file and it will pick
up precisely where it left off. There are a (very) few things that
necessarily change, such as the time and date, and what network
connections are active. But mostly, a persistent DGD program can
keep all objects around forever. When you restore from a dump, it
just looks like the clock skipped, or like you took awhile to run
the next thread of execution, and like all the network connections
suddenly dropped. Effectively, that's what just happened.</p>

<p>Keeping a single run of the program going for so long requires a
<a href="Cleanup.html">object cleanup</a> solution. You need to be
able to find old objects that are no longer in use and destruct
them. Over days, weeks or years, an object leak will eventually
bring your MUD down because old leaked objects will never go away.
Rebooting no longer helps because all your old objects will stick
around across reboots.</p>

<p>But the curse of eternal objects is also a disguised blessing.
You can save a lot of code if you don't need to rebuild all your
object structures when you reboot. You no longer need to write your
data to disk. If you make a change in an object, it stays around
even if you don't have a way to write that change to a data file.
That can be a big, big change in the way you think about your MUD
Library.</p>

<p>Normally, keeping all of your objects in RAM at all times would
mean using a ridiculous amount of memory. However, DGD is a
disk-based server, and believes very strongly in <a href=
"../Operation/Swapping.html">swapping things to disk</a> constantly
to save memory. This means that if you store data as 'in memory'
LPC objects, they wind up taking no more memory or disk space than
if you saved all your idle objects to disk. But you can access LPC
objects in memory instantly, and DGD will transparently handle all
swapping.</p>

<h3>Persistence and Player Bodies</h3>

<p>Persistence is also related to <a href="PlayerBody.html">how you
choose to represent the player</a> in your MUD. Whether the
player's body is represented by a single monolithic object or
separated into a body and a connection object determines whether
you can simply keep the player's body in memory when it's not
connected. Note that you don't have to keep the body visible
in-game to keep the body's LPC object stored somewhere in
memory.</p>

<p>A monolithic object would contain the connection (originating IP
address, the ability to send and receive data), but also all the
player's information like skills, name, password, history and so
on. In a non-MUD application, the equivalent would be user
preferences and settings, interface code, and any avatar the user
might have in the program. Separating out the connection-specific
data (IP address, data transmission) allows you to store the
persistent information like preferences and body data in a separate
object, which (on a persistent server) never needs to be
destructed, nor the settings saved to a file. That saves
save&frasl;load code, as do many other similar situations.</p>

<p>Persistence also affects how equipment may be stored. A player's
equipment can be kept with his body, including any customizations.
The MUD would simply move it to an unused or virtual room, if the
body persists anyway. Doing so is optional, of course, but it's
another form of saving-to-file that can be avoided with a
persistent MUD if the implementor so desires. If your MUD permits
object customization, this can be a way to save it long-term.</p>

<p>You'll need to periodically delete unused players if you need to
free up space, just like you'd have to with player files. You'll
need to list all players and determine whether they've been idle so
long that they need to be deleted. That's usually easier if the
players are stored as in-memory LPC objects rather than needing to
be parsed from data files.</p>

<h3>Upgrading Existing Objects</h3>

<p>A problem with upgrading in-place is that if you change certain
parts of how your LPC objects work, you'll be left with a lot of
LPC data in the old layout, designed for the old code. In a MUD
with save and restore, it's possible to write a datafile adapter
and kludge around this when you reboot. The equivalent for a
persistent MUD is an update function.</p>

<p>To upgrade objects, you'll already need to have object
management code to rebuild files. Your object manager can also call
upgrade functions on master objects easily, and those master
objects can track and upgrade clones. If you're using the Kernel
Library, it's also possible to track clones by owner with the
ObjRegD, or you can roll your own tracking system.</p>

<p>In any case, it's sometimes necessary to write code to
initialize new fields (such as one you just added) in old objects,
or move data from old fields into new ones. It's not harder than
writing a datafile converter that does the same thing, but the
results can be trickier if you do it wrong. Remember, in this case
you're updating live data and you may have players connected at the
time. Backing up first is a useful thing, and it may be useful to
start a secondary 'test' server from a live statedump and try your
upgrade code there first to make sure it works.</p>

<p>You may also find that it's useful to do an upgrade in stages.
For instance, if you change the type and representation of a field
in an LPC object, you may want to add the new one, put the data
into its new location, then do a <i>second</i> LPC upgrade to
remove the old field.</p>

<h4>Example</h4>

<p>For instance, I might change my objects to stop storing a "brief
description" string and instead store offsets into my arrays of
nouns and adjectives to make a description. So if you see a "broad
green tabard" then you're guaranteed you can "look broad green
tabard" since it uses nouns and adjectives in the object.</p>

<p>However, when I take add the new data field (let's say an array
of integer offsets, so it'll be an int pointer), I'll need to fill
in decent values. I could make it default to saying the first two
adjectives, then the first noun. So I'd set the array to <tt>[0, 1,
0]</tt>, where the last element is the offset into the array of
nouns.</p>

<p>So far, so good. But where do I put the code to fill in all
those fields? One answer is "in the ObjectD". My favorite answer is
to have the ObjectD call a function called "upgraded" if it exists
on every object that gets upgraded. That's what Phantasmal
does.</p>

<p>So I could put that code I mentioned above into the upgraded()
function of my object type, then type "%full_recompile" at the
command line, and my objects would all start being described as
"big brown table" and "flat checkered floor" and things, all
according to the first nouns and adjectives on their current lists.
Then I'd go fix all the descs, 'cause that would look funny :-)</p>

<p>But I've had to write specific upgrade code for the specific
change I made to my objects. In a standard MUD, I'd make the change
to the object loading code, then shutdown the MUD and restart it.
Then all my objects would be appropriately altered, but I'd also
have to drop everybody's network connection to do it, and generally
disrupt things. Not nearly as convenient. Plus, it's slow to do all
that loading and saving of LPC objects using LPC code. Much faster
to use a statedump.</p>

<h3>Why No Load and Save?</h3>

<p>If you use statedumps, there's no reason to ever move things out
of memory, usually. You'll need backups, but statedumps are (under
DGD) the fastest available backups if you're writing out most of
your MUD's data. That saves you having to write code for reading
and writing objects, and more importantly for large interconnected
systems of objects.</p>

<p>You may choose to have object load&frasl;save code anyway,
probably for object import&frasl;export. Skotos and Phantasmal both
do this. However, object saving is slow compared to statedumps, so
normally object saving will only be used for export to a different
MUD or different program. You can also use the traditional
save-reboot-load hack for object upgrade, just like a
non-persistent server has to do. That can be easier in some cases,
at the cost of some downtime (and having to write all the
load&frasl;save code!). That's basically how Phantasmal uses
it.</p>

<p>Having the ability to read or write datafiles can also be a good
means of object creation, or to import zones from other types of
MUDs, or similar builder tricks. Outside of your MUD, everything is
going to move around as files, so it can be good to read and write
them.</p>

<h3>Can't This All Be Done Without DGD?</h3>

<p>Certainly. A shovel's not the only way to dig a hole - you can
use a spoon, if you're so inclined. You can write a large amount of
code to save and restore huge interconnected systems of objects.
You can do the years (over a decade now) of testing that DGD has
already received on those systems, and do it all for yourself. None
of this is impossible &mdash; DGD itself is written in C, so
obviously a C-based system will do all of this just fine if it's
designed correctly.</p>

<p>Now: have you asked yourself why you'd ever want to?</p>
<pre>
From: DGD Mailing List (Par Winzell)
Date: Sun Apr  4 11:45:02 2004
Subject: [DGD] Re: Clones and very large arrays

&gt;&gt; ... and one kind of iterator that makes no such promise. Obviously the 
&gt;&gt; former kind has to either use more memory, or special tricks. If you 
&gt;&gt; don't mind the iterator using a fair bit of memory (temporarily) you 
&gt;&gt; can  simply let the iterator LWO make a private copy of the bigmap, 
&gt;&gt; keep two index counters (one to index the mapping of mappings, one to 
&gt;&gt; index the current inner mapping), and step through the whole thing 
&gt;&gt; step by step as next() is called.
&gt; 
&gt; I would have thought this method to be quicker than the find_object 
&gt; method you described.

Depends on the number of objects. In a Skotos game, clones of 
/base/obj/thing constitute &gt; 90% of the objects in the game, and it's 
pretty pointless to keep an explicit data structure around enumerating 
180,000 objects when you can just loop 200,000 times and get them all 
anyway.

&gt; But you still use bigmaps to store the actual clones, right?

Nope. There's no point... for this particular problem, and for clonables 
whose clones constitute a significant portion of the objects in the 
game, find_object() happens to be all you need.

&gt; So as I understand it, the iterator is just a way of retrieving the 
&gt; contents of the datastructure?

Yes, although the emphasis should be on it being THE way; i.e. once you 
start using them, you quickly start taking it for granted that wherever 
there is a data structure, you can fetch its iterator. I can communicate 
these facts but I can't communicate fully the experience. These OO 
concepts seem to solve nothing new, but they change everything.


&gt; And Bart mentioned that it is a useful method of getting rid of 'stray 
&gt; clones'. Unfortunately I don't see how. If you have a 'stray clone' 
&gt; lying around, how are you going to spot it from within a gigantic 
&gt; datastructure?

Again this is one of those things you don't fully understand until you 
have had to administer a persistent game. Once you boot DGD into a game 
that uses state dumps, you will never ever again cold start it. That 
means every persistent resource (i.e. rooted in a persistent object) you 
create will still be with you in the year 2350 unless you have, on th 
very first day of your uptime, administrative code in place that keeps 
track of these objects.

If you have a guest programmer who just executes,

   clone_object("/foo");

without doing something with the return value, and you don't have code 
at a low level that registers this clone somewhere, this clone is more 
or less gone forever. It is never garbage collected (it is not a LWO) 
and nobody has a pointer to it. The only way it can be found is by using 
find_object(), and for that you have to know the path name.

Once you realize what a potentially huge and dark haystack an eternal 
uptime is, and how little of a safetynet there is unless you write one 
yourself, you will see the reason why people here rail against the idea 
of rewriting the kernel library from scratch. There should be a layer of 
code in place on top of DGD and below your mudlib that has been tested 
by dozens of people before you, with all the bugs ironed out, that you 
can rely on with absolute certainty. From the perspective of the mudlib 
writer, such administrative code should be considered more or less part 
of the driver. This discipline is essential.

&gt; Also, as people left me with the impression that they don't often recall 
&gt; the entire list of clones (those who use linked lists), what kind of 
&gt; useful information are they deriving from it?

It's there for the same reason you keep 10 gallons of water in your 
basement for when the earthquake hits, yet you don't amble down there to 
refill your glass during dinner.

Zell
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
