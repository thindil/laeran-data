<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: Script Delays
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="index.html">Writing a Library</a></li>
<ul>
<li><a href="ChangingLPC.html">Changing LPC</a></li>
<li><a href="Cleanup.html">Object Cleanup</a></li>
<li><a href="CmdsOrNot.html">&frasl;cmd vs wiztool</a></li>
<li><a href="CondInherit.html">Conditional Inheritance</a></li>
<li><a href="Database.html">Object Database</a></li>
<li><a href="DistStateDump.html">Distribute a State Dump?</a></li>
<li><a href="DriverObj.html">Designing Driver Objs</a></li>
<li><a href="FTPD.html">FTPD</a></li>
<li><a href="GurbaLib.html">GurbaLib</a></li>
<li><a href="HeartBeat.html">State Dumps</a></li>
<li><a href="Heaven7.html">Heaven7</a></li>
<li><a href="HTTPD.html">HTTPD</a></li>
<li><a href="IMUD3.html">InterMUD3</a></li>
<li><a href="InterruptCall.html">Interrupt Call</a></li>
<li><a href="LargeAuto.html">Designing AUTO Objs</a></li>
<li><a href="LittleIssues.html">Misc Issues</a></li>
<li><a href="NFS.html">NFS</a></li>
<li><a href="ObjBinding.html">Object Binding</a></li>
<li><a href="ObjectManagement.html">Object Management</a></li>
<li><a href="OtherServices.html">Other Net Services</a></li>
<li><a href="Persistence.html">Persistent MUDLibs</a></li>
<li><a href="PlayerBody.html">Player vs Body</a></li>
<li><a href="Precompiling.html">Precompiling</a></li>
<li><a href="Reimplementation.html">Reimplementing From Scratch</a></li>
<li><a href="Releasing.html">Releasing Code</a></li>
<li><a href="Rlimits.html">Rlimits</a></li>
<li>Script Delays</li>
<li><a href="Security.html">Misc Security</a></li>
<li><a href="Sendmail.html">Outgoing Email</a></li>
<li><a href="SoYouWanna.html">So You Want To...</a></li>
<li><a href="StartingNew.html">Start from Scratch?</a></li>
<li><a href="SupDocs.html">Supplementary Documentation</a></li>
<li><a href="Telnet.html">Telnet Protocol</a></li>
<li><a href="UseKernel.html">Using the Kernel</a></li>
<li><a href="UseMelville.html">Using Melville</a></li>
<li><a href="UsePhantasmal.html">Using Phantasmal</a></li>
<li><a href="WebDAV.html">WebDAV</a></li>
<li><a href="WhatLicense.html">Which License</a></li>
</ul>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="../Programming/index.html">DGD LPC Reference</a></li>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">Writing a Library</a> > Script Delays</p>



<h2>Delays in In-MUD Scripting Languages</h2>

<p>In a MUD, mobile scripts and object scripts tend to be pretty
simple. They mostly go through a set of actions in order, with an
occasional conditional (like an 'if' statement) or loop. So mostly
LPC works very well for them, and is far more than they need. In
LPMUDs, it's usually far and away the most convenient to just use
LPC for all your scripting - it's fast, it's flexible, and you've
already got a nice interface to everything your MUD does.</p>

<p>However, there's a problem with that. Specifically, there's a
problem if you want your script to delay for a few seconds or a few
minutes and then start happening again. Say that you want a mobile
to look at what it's been given, wait a few seconds and then give
it back disdainfully. It's important to wait that few seconds. The
problem is that DGD is single-threaded, which means that execution
rounds need to finish quickly so that the rest of the MUD can get
on with what it's doing. A three-second delay loop isn't an option,
and would halt the rest of the MUD, spoiling the effect. It doesn't
work.</p>

<p>One way to do this is to schedule call_outs, or do something
roughly similar. That's a bit ugly because you need to split your
function into pieces -- "give_script_start",
"give_script_after_delay_1", "give_script_after_delay_2", etc.
However, once you get over the syntactic ugliness it's not too bad.
It does what you want it to. You just have to cut your script up
into lots of little sub-scripts.</p>

<p>You could write an entire other language on top of LPC, or
perhaps <a href="ChangingLPC.html">modify LPC in some way</a> for
the scripting language. Or compile the language to LPC. Then you
could interpret that language, which would let you pause it for
delay statements and go back to what you were doing.</p>

<p>You could queue up actions in advance, but have LPC functions
that put actions into the queue. So you'd have functions like
mobile_do_run(), mobile_do_sharpen(), etc that would queue up
actions like "run" and "sharpen" to be done when the current action
is finished. Your scripts could have conditionals and other
interesting code when they first ran, and add actions into the
queue in variable ways. Unfortunately, that means that all control
structures must have finished before any of the delays happen.
That's not great. It means that mobiles will get stupider as the
script goes on for more clock-time. And if a mobile needs to enter
a room and then respond to it, it will need to use some variation
of the call_out approach above.</p>

<p>A third possibility is to run the script again after each delay
statement, and pass some kind of argument to it to tell it where it
came back. So your function would use switch() or if() to jump to
where you should be after the delay. A delay would become a return
statement, along with how long you should delay, and then you'd get
called again with an argument for how long you've delayed or
something. Your builders would hate you and want to kill you, but
it would work.</p>

<p>A popular variation on the above is to write an LPC preprocessor
which will turn you delay() statement into a case for a switch()
statement, and put a switch() inside your function to jump to the
right case. It's potentially more annoying to deal with restoring
values of variables this way, though. Remember that local variables
lose their value if you jump out of the function and then back
in.</p>
<pre>
From: DGD Mailing List (Par Winzell)
Date: Sun Jan  4 11:31:00 2004
Subject: [DGD] Delay statements in scripting

Merry is Skotos' LPC-based scripting system. It's pretty much straight 
LPC with 'additions' -- e.g. delays, which are implemented with the 
switch solution given by Dworkin above.

Merry is parsed using parse_string() and a rathed mutated version of 
Felix's old LPC-grammar-for-parse_string() grammar. It's broken down 
into a binary format and stored in LWO's. The LWO can reconstruct the 
Merry source or underlying LPC source on demand (the former for editing 
the script, the latter for compiling it to a real LPC object).

The systems keeps a cache of a few hundred compiled Merry scripts 
around, but they can be destructed and recompiled on demand.

One tip for anybody implementing this: remember that the compiled 
objects can't keep any real state. For delays, for example, the callouts 
themselves can't be kept in the generated object. You -must- be able to 
destruct such objects at will.

If I execute an action that requires a delay, it's my body that should 
keep the callout, and then relayeto the appropriate script handler when 
the callout expires.

Zell
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
