<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: Player vs Body
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="index.html">Writing a Library</a></li>
<ul>
<li><a href="ChangingLPC.html">Changing LPC</a></li>
<li><a href="Cleanup.html">Object Cleanup</a></li>
<li><a href="CmdsOrNot.html">&frasl;cmd vs wiztool</a></li>
<li><a href="CondInherit.html">Conditional Inheritance</a></li>
<li><a href="Database.html">Object Database</a></li>
<li><a href="DistStateDump.html">Distribute a State Dump?</a></li>
<li><a href="DriverObj.html">Designing Driver Objs</a></li>
<li><a href="FTPD.html">FTPD</a></li>
<li><a href="GurbaLib.html">GurbaLib</a></li>
<li><a href="HeartBeat.html">State Dumps</a></li>
<li><a href="Heaven7.html">Heaven7</a></li>
<li><a href="HTTPD.html">HTTPD</a></li>
<li><a href="IMUD3.html">InterMUD3</a></li>
<li><a href="InterruptCall.html">Interrupt Call</a></li>
<li><a href="LargeAuto.html">Designing AUTO Objs</a></li>
<li><a href="LittleIssues.html">Misc Issues</a></li>
<li><a href="NFS.html">NFS</a></li>
<li><a href="ObjBinding.html">Object Binding</a></li>
<li><a href="ObjectManagement.html">Object Management</a></li>
<li><a href="OtherServices.html">Other Net Services</a></li>
<li><a href="Persistence.html">Persistent MUDLibs</a></li>
<li>Player vs Body</li>
<li><a href="Precompiling.html">Precompiling</a></li>
<li><a href="Reimplementation.html">Reimplementing From Scratch</a></li>
<li><a href="Releasing.html">Releasing Code</a></li>
<li><a href="Rlimits.html">Rlimits</a></li>
<li><a href="ScriptDelays.html">Script Delays</a></li>
<li><a href="Security.html">Misc Security</a></li>
<li><a href="Sendmail.html">Outgoing Email</a></li>
<li><a href="SoYouWanna.html">So You Want To...</a></li>
<li><a href="StartingNew.html">Start from Scratch?</a></li>
<li><a href="SupDocs.html">Supplementary Documentation</a></li>
<li><a href="Telnet.html">Telnet Protocol</a></li>
<li><a href="UseKernel.html">Using the Kernel</a></li>
<li><a href="UseMelville.html">Using Melville</a></li>
<li><a href="UsePhantasmal.html">Using Phantasmal</a></li>
<li><a href="WebDAV.html">WebDAV</a></li>
<li><a href="WhatLicense.html">Which License</a></li>
</ul>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="../Programming/index.html">DGD LPC Reference</a></li>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">Writing a Library</a> > Player vs Body</p>



<h2>Separating Player LPC Objects from Body Objects</h2>

<p>It's possible to separate a player's in-game presence into many
LPC objects, or few. You can have separate LPC objects for the
player, the network connection, the mobile (Skotos uses the phrase
'combat brain' to refer to this object) and the material body, or
you can combine any or all of them to get fewer objects, or just a
single object.</p>

<p>Melville separates the player&frasl;user&frasl;connection object
from the physical body object. Phantasmal goes a step further and
separates out the idea of a mobile into its own object. These
methods make it possible to do tricks like swapping bodies more
easily, and to otherwise reassign network connections, at the cost
of more files, and perhaps more complexity, in the player data.
Swapping bodies is particularly useful for wizards to test NPCs and
impersonate others. The TMI-2 MUDLib uses a similar trick for dead
PCs having ghost bodies.</p>

<p>Phantasmal separates the mobile object out specifically to more
easily allow NPC actions and player actions to share code. By
making player actions "more like" NPC actions, the same functions
can operate for both. Skotos does a similar thing with their
action&frasl;verb separation.</p>

<p>In DGD, it's often useful to separate the player's presence into
multiple objects because the connection object is transient and
goes away when the user disconnects &mdash; DGD will destroy the
network connection object on disconnection. However, the player
data can be stored in other in-game objects. By simply keeping
those objects in existence and attaching them to a new connection
object, you can maintain any modifications to them while never
saving them to outside-the-MUD storage.</p>

<h3>Reassigning Connections</h3>

<p>In DGD, there is a single connection object that DGD recognizes
as representing any single network connection. DGD doesn't have
specific support for reassigning input from one connection to
another, so you're usually better off separating the connection
into its own object and having a way (in the other, non-connection
objects) to reassign what connection's input goes where. Why not
have the driver do it? Because DGD has the philosophy that nothing
that can be easily done in LPC can be done in the driver. The
Kernel Library does the reassignment trick, so obviously it can be
done in LPC.</p>

<h3>Efficiency</h3>

<p>So does all this dividing stuff into objects waste a lot of
space? Well, it'll waste part of a sector for each object, at least
if the resulting objects are small. So that will probably cost you
on the order of a kilobyte for each connected player in your MUD.
So if you have one of the most popular MUDs on the internet, with
about a thousand players connected at peak, this will cost you
about... a megabyte of memory. And that's assuming you're doing a
fair amount of dividing up objects. Consider whether it's worth the
difference in features and maintainability, but the memory usage
isn't a significant difference.</p>
<pre>
From: DGD Mailing List (Par Winzell)
Date: Wed Mar 24 09:18:01 2004
Subject: [DGD] Aliases &amp; Stacked commands

Bart van Leeuwen wrote:

&gt; I think you really want something like this_player() because 'users' are
&gt; not the only livigns that can use 'commands' on your average mud, which
&gt; means to me that commands should never ever depend on this_user() since
&gt; they will fail when used by a living thats not linked to any user.
&gt; Of course there can be exceptions for security reasons, but those are
&gt; cases where runnign such a command from an alias would not be a good idea
&gt; either I believe.

I certainly agree that a living object should not depend on having a 
connected user for any of its in-world actions. In Skotos we separated 
commands and actions entirely -- commands belong to the text interface 
layer, actions are in the virtual world. Commands cause actions. NPC 
brains cause actions.

We deliberately rejected this_player(), though. As I recall, half of the 
  code in the old LPC driver is concerned with making sure this_player() 
has the right value at all times. It needs to be switched in and out 
constantly, depending on which function is being called where.

Instead, we simply pass along an explicit 'actor' variable.

As concerns this_user(), I ended up implementing a query_originator(), 
which is a version of this_user() that is persisted across call_outs. 
Originally this change was motivated by the fact that LPC is single 
threaded, and thus anything that touches the network has to use a 
callback approach to waiting for responses. Obviously, DGD's idea of 
this_user() does not survive that kind of 'wait', and so we wrote a 
bunch of infrastructure to bridge the gap. The main purpose was for 
runtime error reporting to continue arriving at the originating 
connection even after the callback.

Later, we've had to spread more and more processes out into 
callout-driven background processes. It's nice to have runtime error 
reporting continue to function there, too.

Zell
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
