<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: Object Management
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="index.html">Writing a Library</a></li>
<ul>
<li><a href="ChangingLPC.html">Changing LPC</a></li>
<li><a href="Cleanup.html">Object Cleanup</a></li>
<li><a href="CmdsOrNot.html">&frasl;cmd vs wiztool</a></li>
<li><a href="CondInherit.html">Conditional Inheritance</a></li>
<li><a href="Database.html">Object Database</a></li>
<li><a href="DistStateDump.html">Distribute a State Dump?</a></li>
<li><a href="DriverObj.html">Designing Driver Objs</a></li>
<li><a href="FTPD.html">FTPD</a></li>
<li><a href="GurbaLib.html">GurbaLib</a></li>
<li><a href="HeartBeat.html">State Dumps</a></li>
<li><a href="Heaven7.html">Heaven7</a></li>
<li><a href="HTTPD.html">HTTPD</a></li>
<li><a href="IMUD3.html">InterMUD3</a></li>
<li><a href="InterruptCall.html">Interrupt Call</a></li>
<li><a href="LargeAuto.html">Designing AUTO Objs</a></li>
<li><a href="LittleIssues.html">Misc Issues</a></li>
<li><a href="NFS.html">NFS</a></li>
<li><a href="ObjBinding.html">Object Binding</a></li>
<li>Object Management</li>
<li><a href="OtherServices.html">Other Net Services</a></li>
<li><a href="Persistence.html">Persistent MUDLibs</a></li>
<li><a href="PlayerBody.html">Player vs Body</a></li>
<li><a href="Precompiling.html">Precompiling</a></li>
<li><a href="Reimplementation.html">Reimplementing From Scratch</a></li>
<li><a href="Releasing.html">Releasing Code</a></li>
<li><a href="Rlimits.html">Rlimits</a></li>
<li><a href="ScriptDelays.html">Script Delays</a></li>
<li><a href="Security.html">Misc Security</a></li>
<li><a href="Sendmail.html">Outgoing Email</a></li>
<li><a href="SoYouWanna.html">So You Want To...</a></li>
<li><a href="StartingNew.html">Start from Scratch?</a></li>
<li><a href="SupDocs.html">Supplementary Documentation</a></li>
<li><a href="Telnet.html">Telnet Protocol</a></li>
<li><a href="UseKernel.html">Using the Kernel</a></li>
<li><a href="UseMelville.html">Using Melville</a></li>
<li><a href="UsePhantasmal.html">Using Phantasmal</a></li>
<li><a href="WebDAV.html">WebDAV</a></li>
<li><a href="WhatLicense.html">Which License</a></li>
</ul>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="../Programming/index.html">DGD LPC Reference</a></li>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">Writing a Library</a> > Object Management</p>



<h2>Managing and Upgrading DGD Objects</h2>

<p>DGD is impressive in the degree of upgradability and <a href=
"Persistence.html">persistence</a> that it offers. However, to take
full advantage of the upgradability, you'll need to observe some
ground rules.</p>

<p>DGD's <a href="../Kernel/Inheritance.html">inheritance</a>
features aren't quite the same as a regular LPMUD, though they're
far more powerful if used correctly.</p>

<p>You'd like to be able to upgrade all your code while leaving
your data in place. For instance, you'd like to be able to write a
new feature for your MUD, and enable it while players are logged
in. Before the recompile, the feature isn't there. After the
recompile, it is. Players don't see any difference until they try
the new command, which works after the recompile. This is less of a
pipe-dream than it sounds. <a href=
"http://phantasmal.sf.net">Phantasmal</a> already does it using the
%full_rebuild command, and the Kernel Library has a less automated,
more awkward way to do it, but it can work. Sadly, few other DGD
libraries (except the closed-source <a href=
"http://www.skotos.net">Skotos</a> servers) seem to do this.</p>

<p>One reason that few libraries bother to do this is that it
requires tracking all object compilation and inheritance. The
Kernel Library makes this slightly easier by encapsulating that
functionality into an Object Manager (see the LPC Examples section
for several Object Managers, or download Phantasmal and look at
that one).</p>

<p>There are some other related tricks you can do. It's usually
very convenient to call a function on objects that are recompiled
but also have data. The data may need to be updated after the
change in code. Phantasmal calls an "upgraded" function in any
recompiled master object, if it exists (if clones or LWOs need to
be updated, the master must keep a list of them or they must be
looked up using the Kernel Library tracking facilities). <a href=
"http://www.skotos.net">Skotos'</a> libraries use a different
method based on the call_touch kfun to update objects as they are
used. This makes a great deal of sense, given the quantities of
objects that Skotos' libraries deal with.</p>

<p>As a random aside, remember that an object isn't compiled until
the end of the thread where compile_object() gets called. So there
are some subtle issues about what version of the "upgraded"
function gets called. The old one, already compiled into the
object? The new one, the one that isn't currently compiled? You may
need to call_out() to a function that will call upgraded()
<i>after</i> the end of the current thread so that the object will
be recompiled, and the <i>new</i> version of upgraded() will be
called.</p>

<p>John "West" McKenna's Inferno library has a significantly more
complex approach, which allows for more interesting upgrades in
some cases. Its upgrader builds a list of objects that need
recompiling. It calls uninit() on them, then upgrading(). Then it
recompiles, then calles upgraded() and finally init().</p>

<p>The uninit() and init() functions are expected to do everything
that's required when an object moves from one place to another
except the actual move. This includes removing&frasl;adding
commands defined by the object from&frasl;to the user's grammar
table.</p>

<p>upgrading() and upgraded() are very rarely used. They're there
in case the new version of the code needs extra initialising.</p>

<p>The Kernel Library uses what's called an <a href=
"../Kernel/ObjectManager.html">Object Manager</a>, or ObjectD, to
do all of this. That doesn't change what you can do, but it does
alter some of the code.</p>

<h3>Turning Stuff Off</h3>

<p>If you're upgrading more than one object, or you're upgrading an
object and its upgraded() function hasn't been called yet, you'll
need to be sure to suspend network connections and network input
while all that is going on. If you're halfway through an upgrade,
it's dangerous to allow commands to execute, whether from players
or NPCs, because objects may call other objects that aren't
recompiled or upgraded yet. If you turn off new network
connections, and turn off call_out() statements to every object
except the one doing the upgrading (the Kernel Library has good
ways to do this) then you can do a multi-object upgrade safely.</p>

<p>If you do this, be absolutely <i>certain</i> to have appropriate
catch() and rlimits() statements that will allow you to turn
call_out() statements and network input back on. Otherwise an error
in an upgraded() function can hang your MUD completely, with no way
to fix it, not even with the 'safety' binary port that the Kernel
Library supplies.</p>
<pre>
From: John "West" McKenna
Subject: Re: [DGD]compile_object() kfun
Date: Wed, 14 Mar 2001 17:15:30 +0800 (WST)

The auto-upgrader builds a dependancy tree from inherits, includes,
and calls from the object to a depends() function.  The object can
declare its dependance on any files or directories.  Directory
dependence allows the object to be re-initialised when, for example, a
new soul command file is added.
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Mon Jan 12 07:24:01 2004
Subject: [DGD] Re: Recursion in recompile(), is this correct?

Bart van Leeuwen wrote:

&gt; On Sat, 10 Jan 2004, Noah Gibbs wrote:
&gt;
&gt; &gt; --- Erwin Harte wrote:
&gt; &gt; &gt; Which is where the 'block_input' kfun might come in
&gt; &gt; &gt; handy. ;)
&gt; &gt;
&gt; &gt;   Yeah.  I do it during the recompile, I just don't do
&gt; &gt; it 'til all of the upgraded() call_out statements are
&gt; &gt; done.  I need to.
&gt;
&gt; I was thinking a bit about this and am wondering how safe this is.
&gt; Of course if you rely on everything on your mud being upgraded, you will
&gt; need some mechanism for upgrading everything before anything else happens
&gt; on the mud.
&gt;
&gt; Will it work to do this in call_outs and just block input untill you are
&gt; done?
&gt; I can imagine that this will still allow for other call_outs to run in
&gt; between your upgrade call_outs, and as a result, other threads can run
&gt; while you are doing your upgrade still.
&gt;
&gt; My take would be that you really need to do this all at once, and just
&gt; ensure you do not run out of ticks by properly using rlimits
&gt;
&gt; Also, I do not see what you get from splitting it up over multiple
&gt; call_outs, you are going to block the entire mud anyway, and imho it would
&gt; be more efficient to finish the task at hand as quickly as possible.
&gt;
&gt; What I am suggesting is to use unlimited ticks for a 'main loop' that goes
&gt; through all the objects that need to be upgraded, and use a limit only for
&gt; each individual upgrade.

This works fine as long as all of your objects with programs can be held
in memory together.  In some muds, that is not feasible.  In such a case,
you have to break up the upgrading process in order to let DGD swap out
objects between LPC threads.

You do have to block callouts as well as input from users, in order to
prevent interruptions.  These are both dangerous operations, since an
error can effectively halt the mud without a way to restart it.  But it
can be done.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Noah Gibbs)
Date: Mon Jan 12 08:42:01 2004
Subject: [DGD] Re: Recursion in recompile(), is this correct?

--- Bart van Leeuwen wrote:
&gt; &gt; You do have to block callouts as well
&gt; &gt; as input from users, in order to
&gt; &gt; prevent interruptions.  These are both
&gt; &gt; dangerous operations, since an
&gt; &gt; error can effectively halt the mud without
&gt; &gt; a way to restart it.  But it
&gt; &gt; can be done.

  Yeah.  It's not actually so bad...  It's just a
matter of making sure you've got strategically-placed
catch() statements so that an error can be recovered
from.  At least, that's been my experience.

&gt; Yep, call_outs, input of any kind... sounds like
&gt; lots of fun to me..

  Yup.  There's an easy way to block call_outs, it
turns out, in the Kernel Library resource manager. 
Ditto for input.  I don't think the input-blocking
thing works for connections, so I actually have a
separate "suspended" message that you get when you try
to connect to the MUD while it's upgrading.  It tells
you to try back in about ten seconds.  It doesn't take
nearly a full ten seconds to rebuild, but I figure a
conservative estimate is better :-)

  But yeah, as Felix notes, make sure you have catch
blocks in the right locations so that an error will
cancel everything (or at least, cancel the operation
that just had the error and not reschedule it) and
restore call_outs and input and new connections.

  I actually do this when doing my %datadump operation
too...  Since I'm saving all the objects in the MUD, I
have to keep people and critters from moving around
and giving me an inconsistent state.  That would be
yet *another* disadvantage of data files compared to
state dumps, alas.  So for periodic backups, I
recommend statedumps :-)
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Mon Jan 12 14:26:01 2004
Subject: [DGD] Re: Recursion in recompile(), is this correct?

Noah Gibbs wrote:

&gt; --- Bart van Leeuwen wrote:
&gt; &gt; Hmm. has anyone ever tried a setup where
&gt; &gt; upgrades of 'children' of a
&gt; &gt; recompiled library are delayed untill the
&gt; &gt; next time the child is
&gt; &gt; referenced?
&gt;
&gt;   I guess you could use the (very new) call_touch for
&gt; this...  Prior to call_touch there was no real way to
&gt; tell when the object was referenced so you couldn't do
&gt; it that way.

Don't forget that a recompiled program is not replaced until the end
of the current LPC thread.  You can use call_touch() in the upgrade
of object dataspaces, though.  For example, to initialize a new
variable that has been added.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Tue Jan 13 16:08:01 2004
Subject: [DGD] 1.2.71

What I forgot to mention: the 1.2.71 patch includes a change to the
driver object in the kernel library.  To upgrade this object to the
new version in a persistent mud, you have to recompile it and then
immediately reboot the mud.

The upgrade to the auto object is safe and can be performed at any
time.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Sat Feb 14 10:46:01 2004
Subject: [DGD] 1.2.77

diff -c dgd/src/Changelog:1.314 dgd/src/Changelog:1.315
*** dgd/src/Changelog:1.314     Thu Feb  5 15:01:00 2004
--- dgd/src/Changelog   Sat Feb 14 17:32:13 2004
***************
*** 1573,1575 ****
--- 1573,1577 ----
   - Make sure that a callout handle is not truncated to 16 bits before an
     attempt is made to remove it.
   - Include system files before DGD files on Windows.
+  - Rather than causing an error, let the callout and precompiled object lists
+    returned by status() be nil if they would not fit in an array.

ftp://ftp.dworkin.nl/pub/dgd/experimental/patches/1.2.76-1.2.77.gz

This patch includes the promised changes to the kernel library.  It
also simplifies upgrading a persistent mud from kernel library version
1.2.21 (included with DGD 1.2.71); rebooting immediately after the
driver object is recompiled is no longer necessary.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Wed Aug  4 17:51:02 2004
Subject: [DGD] Object handling

Steve Wooster wrote:
&gt;      I'm trying to plan writing an object handler, but I've come across an 
&gt; issue (pardon the pun) where I'm not sure what would be better... I'm 
&gt; trying to decide whether or not updating the auto object and doing a full 
&gt; recompile should be unnoticeable, or whether it should affect inheritance 
&gt; "trees" (is hierarchy a better word?).
&gt;
&gt;      Let's say you have ObjectA which inherits ObjectB, and they both 
&gt; inherit Auto. You make a change to ObjectB, so now there's ObjectB_Issue2 
&gt; which inherits Auto, but ObjectA is still inheriting the old version of 
&gt; ObjectB. Now, let's say you make a new version of the auto object and do a 
&gt; full recompile... Should ObjectA still inherit the old issue of ObjectB 
&gt; (but with both now inheriting the new auto object), or should it inherit 
&gt; ObjectB_Issue2? It'd be much simpler to do the latter, but I worry about if 
&gt; that could make updating the auto object less transparent, as it would 
&gt; bring inheritance "trees" up-to-date as a side effect (and possibly an 
&gt; undesirable one). Any opinions? Thanks!

If bringing all objects involved up to date can cause problems, then not
doing so can cause problems as well.  For example, suppose that the
change in ObjectB anticipated a change in the auto object.  In that case,
reverting back to the older ObjectB issue would be an error.

Regards,
Dworkin
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Erwin Harte)
Date: Wed Mar 20 23:21:01 2002
Subject: [DGD] Inherits.

On Wed, Mar 20, 2002 at 10:44:45PM -0600, Erwin Harte wrote:
&gt; On Thu, Mar 21, 2002 at 04:19:09AM +0100, Vladimir I. Lazarenko wrote:
&gt; &gt; Hello DGD,
&gt; &gt; 
&gt; &gt;   Hmm. I'm a bit puzzled here. Let's say I'm making changes to a
&gt; &gt;   files, that is inherited to some kind of other file. If i try to
&gt; &gt;   update inherit itself, it says that i can't update inherited file.
&gt; 
&gt; Right.
&gt; 
&gt; &gt;   If i dest the object that inherits that file, update the inherit and
&gt; &gt;   clone object back, my changes do not work.

Forgot to finish a sentence here:

&gt; If you destructed and compiled both objetcts (in the right order) it
&gt; should now be effective for new clones, at least.  However
                                                             if you
  never destructed the inherited object and only destructed and compiled
  the inheriting object, that won't do you any good and actually means
  that any clones already made of the object now use code that you can't
  replace anymore.

Cheers,

Erwin.
-- 
Erwin Harte
</pre>
<hr>

<p>(Blocking Input - necessary for upgrades!)</p>
<pre>
From: dgd at list.imaginary.com (Stephen Schmidt)
Date: Fri Oct 24 09:33:00 2003
Subject: [DGD] dgd crashes on fatal errors

Soja wrote:
&gt; &gt; I have discovered that dgd crashes (dumps core) after reporting a fatal
&gt; &gt; error. For example if you remove the binary_connect() function from a driver
&gt; &gt; object, dgd crashes....

So Don't Do That.  :)

There's no reason to omit this function from the driver. If you don't
want a binary connection object, then

object binary_connect() {
    return 0;
}

ought to work just fine for you. As Dworkin pointed out in his
post, there are good reasons for the driver to abort in this
case and no reason not to insist that certain critical functions
be defined, if only minimally, in the driver object.

Question: Is it possible to turn off listening on a binary
port, either by not specifying a binary port at all in the
config file, or perhaps by specifying -1? I can see where
someone might want to not even be listening for a connection,
rather than listening but refusing to provide an object if
a connection request comes in.

Steve
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Erwin Harte)
Date: Fri Oct 24 09:39:00 2003
Subject: [DGD] Re: dgd crashes on fatal errors

On Fri, Oct 24, 2003 at 10:32:11AM -0400, Stephen Schmidt wrote:
&gt; Soja wrote:
&gt; &gt; &gt; I have discovered that dgd crashes (dumps core) after reporting a fatal
&gt; &gt; &gt; error. For example if you remove the binary_connect() function from a driver
&gt; &gt; &gt; object, dgd crashes....
&gt; 
&gt; So Don't Do That.  :)
&gt; 
&gt; There's no reason to omit this function from the driver. If you don't
&gt; want a binary connection object, then
&gt; 
&gt; object binary_connect() {
&gt;     return 0;
&gt; }

This is the same as what the original poster tried with the 'return
nil;', except you're running with a different strict-typing mode.
It'll cause an intentional coredump as s/he showed.

[...]
&gt; Question: Is it possible to turn off listening on a binary
&gt; port, either by not specifying a binary port at all in the
&gt; config file, or perhaps by specifying -1? I can see where
&gt; someone might want to not even be listening for a connection,
&gt; rather than listening but refusing to provide an object if
&gt; a connection request comes in.

You can currently provide an array of port-numbers.  It's on the todo
list to make it possible to put an empty array there and have no
binary (or telnet) ports open at all.

For now, create a dummy object that self-destructs as soon as it has
been created, so you can clone one of those and return it in
binary_connect() instead of nil or 0.

Hope that helps,

Erwin.
-- 
Erwin Harte
</pre>
<hr>
<pre>
From: dgd at list.imaginary.com (Erwin Harte)
Date: Tue Apr 20 22:29:01 2004
Subject: [DGD] Re: blocking the telnet port

On Wed, Apr 21, 2004 at 12:55:02PM +1000, Mercy wrote:
[...]
&gt; Annyway, I was just wondering if there's a way to block the telnet port, 
&gt; under the Kernel Lib without making direct changes to the kernel itself.
&gt; You might wonder why I'd want to, so briefly, I intend to write a telnet 
&gt; handler to run on the binary port, and rather than just ignoring the 
&gt; existance of the open telnet port, I'd like to close it altogether.

In recent versions of DGD the 'telnet_port' entry in the configuration
file can be an integer or a mapping and as far as I remember you
should be able to make that an empty mapping, causing no telnet ports
to be opened at all.

&gt;From the 1.2.72 Changelog diff:

+  - Config file change.  ({ 6047, 6048 }) for ports changed to a mapping in
+    which the address must also be specified: ([ "*":6047, "localhost":6048 ])

Hope that helps,

Erwin.
-- 
Erwin Harte
</pre>
<hr>
<pre>
From: DGD Mailing List (Robert Forshaw)
Date: Thu Apr  1 17:55:01 2004
Subject: [DGD] players, inheritance, cloning, a better solution?

I have an object called primary_object.c, which contains behaviour code for 
all objects existing in the game world (rooms, items, and entities). This 
object was not intended for inheritance, but rather it would be cloned have 
each clones' behaviour defined by configuration files. I also want actual 
players to be primary objects.

Now, I could put all the code for interactivity into the primary_object, but 
this seems a rather inefficient solution since most objects wouldn't be 
making any use of the interactive code. So I've got a seperate object, 
called player.c. But if I inherit primary_object in order to adopt its 
behaviour, it won't be clonable any longer.

My solution has been to make another file, _primary_object.c for lack of a 
better name, all that does is inherit primary_object.c. So primary_object.c 
becomes a library and _primary_object.c the clonable.

I'm just wondering if anyone can spot a more attractive solution than the 
one I've just described, as it seems rather 'hackish', if you know what I 
mean.
</pre>
<hr>
<pre>
From: DGD Mailing List (Par Winzell)
Date: Thu Apr  1 22:29:01 2004
Subject: [DGD] players, inheritance, cloning, a better solution?

Robert,

&gt; My solution has been to make another file, _primary_object.c for lack of 
&gt; a better name, all that does is inherit primary_object.c. So 
&gt; primary_object.c becomes a library and _primary_object.c the clonable.
&gt; 
&gt; I'm just wondering if anyone can spot a more attractive solution than 
&gt; the one I've just described, as it seems rather 'hackish', if you know 
&gt; what I mean.

Your choice of names bewilders me slightly, but the idea itself is not 
hackish. Skotos, for example, has

   /base/lib/thing.c

which is the base of all physical objects, and contains all the code, 
and we have

   /base/obj/thing.c

which consists of little but an inherit-statement.

Zell
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
