<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />

  <title>The Phantasmal MUDlib for DGD: Designing AUTO Objs
</title>
  <link href="../../css/default.css" type="text/css" rel="stylesheet" />
</head>

<body>
  <div class="header_pane">
    <p>Phantasmal MUD Lib for DGD</p>

  </div>

  <div class="banner_pane">
    <table class="banner">
  <tr>
    <td class="banner" align="center"><a href=
    "http://validator.w3.org/check/referer"><img src=
    "http://www.w3.org/Icons/valid-xhtml10" alt=
    "Valid XHTML 1.0 Strict!" style=
    "border: 0; width: 88px; height: 31px;"></a> <a href=
    "http://jigsaw.w3.org/css-validator/check/referer"><img src=
    "http://jigsaw.w3.org/css-validator/images/vcss" alt=
    "Valid CSS!" style="border: 0; width: 88px; height: 31px;"></a>
    <a href="http://sourceforge.net"><img src=
    "http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
    style="border: 0; width: 125px; height: 37px;" alt=
    "SourceForge.net Logo"></a></td>
  </tr>
</table>

  </div>

  <table>
    <tr>
      <td valign="top" class="index_pane">
        <ul>
<li><a href="../../index.html">Phantasmal Site</a></li>
<ul>
<li><a href="../../History.html">History</a></li>
<li><a href="../../Installing.html">Installing Baseline Phantasmal</a></li>
<li><a href="../../Comparison.html">Comparison to Other Libs</a></li>
<li><a href="../../Credits.html">Credits</a></li>
<li><a href="../../Current.html">Current Features</a></li>
<li><a href="../../WhatIsPhantasmal.html">About</a></li>
<li><a href="../../API/index.html">Phantasmal API</a></li>
<li><a href="../../Archive/index.html">Archive</a></li>
<li><a href="../../Design/index.html">Design</a></li>
<li><a href="../../Development/index.html">Development</a></li>
<li><a href="../index.html">DGD</a></li>
<ul>
<li><a href="../Manual/index.html">DGD Reference Manual</a></li>
<li><a href="../Contribute.html">Contributing to DGD</a></li>
<li><a href="../CSharp_vs_DGD.html">CSharp vs DGD</a></li>
<li><a href="../DGD_Terms.html">DGD Glossary</a></li>
<li><a href="../Java_vs_DGD.html">Java vs DGD</a></li>
<li><a href="../Misc_DGD.html">Miscellaneous DGD</a></li>
<li><a href="../MudOS_vs_DGD.html">MudOS vs DGD</a></li>
<li><a href="../MUDs_using_DGD.html">DGD MUDs</a></li>
<li><a href="../SlushBucket.html">Slush Bucket</a></li>
<li><a href="../Why_DGD.html">Why Use DGD?</a></li>
<li><a href="../Config/index.html">Getting DGD</a></li>
<li><a href="../GameDesign/index.html">Game Design Issues</a></li>
<li><a href="../Kernel/index.html">The Kernel Library</a></li>
<li><a href="index.html">Writing a Library</a></li>
<ul>
<li><a href="ChangingLPC.html">Changing LPC</a></li>
<li><a href="Cleanup.html">Object Cleanup</a></li>
<li><a href="CmdsOrNot.html">&frasl;cmd vs wiztool</a></li>
<li><a href="CondInherit.html">Conditional Inheritance</a></li>
<li><a href="Database.html">Object Database</a></li>
<li><a href="DistStateDump.html">Distribute a State Dump?</a></li>
<li><a href="DriverObj.html">Designing Driver Objs</a></li>
<li><a href="FTPD.html">FTPD</a></li>
<li><a href="GurbaLib.html">GurbaLib</a></li>
<li><a href="HeartBeat.html">State Dumps</a></li>
<li><a href="Heaven7.html">Heaven7</a></li>
<li><a href="HTTPD.html">HTTPD</a></li>
<li><a href="IMUD3.html">InterMUD3</a></li>
<li><a href="InterruptCall.html">Interrupt Call</a></li>
<li>Designing AUTO Objs</li>
<li><a href="LittleIssues.html">Misc Issues</a></li>
<li><a href="NFS.html">NFS</a></li>
<li><a href="ObjBinding.html">Object Binding</a></li>
<li><a href="ObjectManagement.html">Object Management</a></li>
<li><a href="OtherServices.html">Other Net Services</a></li>
<li><a href="Persistence.html">Persistent MUDLibs</a></li>
<li><a href="PlayerBody.html">Player vs Body</a></li>
<li><a href="Precompiling.html">Precompiling</a></li>
<li><a href="Reimplementation.html">Reimplementing From Scratch</a></li>
<li><a href="Releasing.html">Releasing Code</a></li>
<li><a href="Rlimits.html">Rlimits</a></li>
<li><a href="ScriptDelays.html">Script Delays</a></li>
<li><a href="Security.html">Misc Security</a></li>
<li><a href="Sendmail.html">Outgoing Email</a></li>
<li><a href="SoYouWanna.html">So You Want To...</a></li>
<li><a href="StartingNew.html">Start from Scratch?</a></li>
<li><a href="SupDocs.html">Supplementary Documentation</a></li>
<li><a href="Telnet.html">Telnet Protocol</a></li>
<li><a href="UseKernel.html">Using the Kernel</a></li>
<li><a href="UseMelville.html">Using Melville</a></li>
<li><a href="UsePhantasmal.html">Using Phantasmal</a></li>
<li><a href="WebDAV.html">WebDAV</a></li>
<li><a href="WhatLicense.html">Which License</a></li>
</ul>
<li><a href="../LPC/index.html">Untitled document (LPC/index.base.html)</a></li>
<li><a href="../Operation/index.html">What Does It Do?</a></li>
<li><a href="../Programming/index.html">DGD LPC Reference</a></li>
<li><a href="../Running/index.html">Running a MUD</a></li>
<li><a href="../Skotos/index.html">Skotos</a></li>
</ul>
<li><a href="../../Innsmouth/index.html">Innsmouth MUD</a></li>
<li><a href="../../Operation/index.html">Phantasmal Operation</a></li>
<li><a href="../../Setup/index.html">Setup</a></li>
<li><a href="../../Test/index.html">Test module index</a></li>
<li><a href="../../Tutorial/index.html">Phantasmal Tutorials</a></li>
</ul>
</ul>

      </td>
      <td valign="top" class="content_pane">
        <p><a href="index.html">Phantasmal Site</a> > <a href="index.html">DGD</a> > <a href="index.html">Writing a Library</a> > Designing AUTO Objs</p>



<h2>Designing Your AUTO Object</h2>

<p>There are a number of tradeoffs in designing your AUTO object.
One of the simplest, and the most fundamental, is: how much
functionality will it have? Will you have a simple AUTO object with
only the barest and most necessary functionality, rather like the
Kernel Library? Will you have an AUTO object containing a wide
variety of standard library functions on strings and data
structures? Will you include functions on finding an object's
physical (in the MUD) environment and inventory?</p>

<p>Remember that any data in your AUTO object is duplicated
throughout every object in the MUD. This includes LWOs and other
objects that you may want to be fairly small &mdash; DGD has no
structures, so if your single global AUTO object is huge, then
there will be no such thing as a small object in your MUD unless
you build it out of arrays and mappings.</p>

<p>However, remember also that if you take all the data and
functionality out of the AUTO object, you'll need to explicitly
inherit other libraries and perhaps use (slow) call_other()
statements to call your commonly-used functions.</p>

<h3>Driver Issues, Size and Space</h3>

<p>In DGD, there is an obscure cost associated with functions in
the AUTO object that are neither static nor private: all such
functions have a cost of two bytes a piece in <i>every</i>
inheriting object's program. This is also true for non-private
functions in all other (i.e. non-auto) objects.</p>

<p>Normally, this is not much of a problem. However, if you were to
have 200 such functions in the auto object, every other program in
the game but that of the driver object would become 400 bytes
larger.</p>

<p>You can solve this by either keeping such functions out of the
AUTO object, or by making the functions static so that only
subclasses can call them.</p>

<p>There is no speed issue with a large number of functions. DGD
does excellent caching, and on average the cost of a function call
does not increase with the number of functions available. However,
do remember that regardless of other factors, no amount of caching
will make a call_other() as fast as a local function call.</p>

<h3>Function Performance</h3>

<p>There are several performance issues to consider when deciding
whether to put a particular function into the AUTO object.</p>

<p>A call to a function in the auto object uses the special
CALL_AFUNC instruction, which is 3 bytes in size. Exactly the same
functionality would be available with the CALL_DFUNC instruction,
which takes 4 bytes. Thus, programs that call functions in the auto
object will be slightly smaller. In the most extreme case, a
function that consists of nothing but function calls will be almost
25% smaller if CALL_AFUNC can be used for every call. There will be
a barely measurable performance difference.</p>

<p>Note that programs larger than 2K are compressed before being
saved in the swap file, where the compression factor depends on the
redundancy of the byte code, so the size advantage in the swap file
would be much less than 25% if the function mentioned above is
large enough.</p>

<p>Inheriting a utility object, which itself does not inherit
anything, increases the size of the inheriting program by about 16
bytes.</p>

<p>Putting everything into the auto object increases the size of
the working set. For a single object the difference won't amount to
much, but a mudlib wholly designed with the idea of keeping the
working set small will have a performance advantage. For a
different take on "working set", consider processor cache vs. main
memory, rather than main memory vs. disk storage. The Xeon
processor has a 1 Mb cache. Keeping the working set small enough to
fit inside that cache will be an enormous speedup.</p>

<p>You can move functions into a separate 'manager' object rather
than the AUTO object. You'll be replacing calls to an inherited
function with call_other statements. A call_other is slower than a
local function call, especially if the first argument is a string
(since an additional call_other to the driver object will be needed
to resolve the object name).</p>

<h3>Multiple Files and File Size</h3>

<p>It's often convenient to break functionality up into separate
files. Normally in DGD that means parent objects. The functionality
and variable scope are kept separate, and cleanliness is
maintained. The AUTO object can't inherit from any libraries. If it
did, they would inherit it again (since every library does), which
would make a circular dependency.</p>

<p>However, if you're making a large AUTO object and want the
convenience of multiple files, you <i>can</i> use #include to put
them all in one place rather than using 'inherit'. This is one of
the few times that #include is a reasonable way to add functions to
an object.</p>
<hr>
<pre>
From: dgd at list.imaginary.com (Erwin Harte)
Date: Wed Mar 20 23:03:00 2002
Subject: [DGD] Mudlibs?

On Thu, Mar 21, 2002 at 02:56:11AM +0100, Vladimir I. Lazarenko wrote:
&gt; Hello Erwin,
&gt; 
&gt; Hmm. and if i inherit it into auto.c object?
&gt; Will i be able to use it whereever?

You don't _inherit_ things into the auto object, you'll have to
#include them into it.  But yes, if you do that, you will be able to
use it whenever.

Now, personally I'd consider that really bad form and would prefer to
have something like /lib/sprintf.c available for the objects that
actually _need_ it.  But maybe that's just me, I like to keep the
auto-object(s) lean and mean, makes it less likely that security or
consistency bugs creep in.

Oh, and your reminder of the day:

&gt; EH&gt; Aside: Responding after that which is relevant would be appreciated.

Thanks in advance,

Erwin.
-- 
Erwin Harte
</pre>
<hr>
<pre>
From: DGD Mailing List (Erwin Harte)
Date: Wed Jan  7 11:15:02 2004
Subject: [DGD] Re: masking kfuns

On Wed, Jan 07, 2004 at 04:53:45PM +0000, Robert Forshaw wrote:
&gt; How do I mask a kfun, and how do I refer to the original function? Is it 
&gt; anything like driver::kfun() ?

Yes.  In your auto-object, you can do something like this:

    static object find_object(string path)
    {
        /* Do some of your own sanitizing of input, etc. */

        /* ... */
        
        return ::find_object(path);
    }

&gt; Once the function is masked is it possible for someone to do driver::kfun() 
&gt; to bymass the masked version? If so how can I prevent it?

If you redefine the function in the auto-object, then only code in the
auto-object can use ::function() to access the original.  And of
course the driver-object can, assuming you don't do bizarre things
like inheriting the auto-object, there.

Cheers,

Erwin.
-- 
Erwin Harte
</pre>
<hr>
<pre>
From: DGD Mailing List (Par Winzell)
Date: Sat Mar 13 10:13:01 2004
Subject: [DGD] getting started with DGD

&gt;&gt;   You can search one string for another using "explode" if you're
&gt;&gt; clever.  Or with parse_string.  The position of an element in an array
&gt;&gt; is just going to require you to use a for() loop.
&gt; 
&gt; Wow.  these seem like fairly basic things.  Its like the three bears.  
&gt; for() is too low level (papa bear), parse_string is too high level (mama 
&gt; bear), and using explode for string search sounds the the crazy uncle 
&gt; bear that nobody wants to talk about.  :)

The idea is that DGD focuses on doing the driver part right, and the 
things you'd consider essential to writing a mudlib -- like a string 
search function -- belong in a middle layer. If you chose to reject the 
existing middle layers, as many do, you also forfeit the right to say 
that DGD is too minimalistic.

All three bears are examples of how a kernel (or System) level library 
could choose to implement a user-friendly function. A mudlib developer 
should not need to meet the bears in person.


&gt; Doesn't pretty much every one end up having to write their own 
&gt; proprietary string library?

Well, the term 'proprietary' is a little misleading, since by and large 
everybody who writes something for DGD publishes it to the world...

Zell
</pre>

      </td>
    </tr>
  </table>

  <div class="footer_pane">
    <p>Copyright (C) 2010 Raymond Jennings</p>

<p>This website is released to the public under the terms of the
GNU Free Documentation License, Version 1.3 or later</p>

  </div>
</body>
</html>
